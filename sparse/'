// A sparse array package based on
// https://github.com/skelterjohn/go.matrix/

package sparse

import (
	"fmt"
)

var BoundsCheck = true // Whether to check array bounds every time

// Sparse array with an arbitrary number of dimensions
type SparseArray struct {
	elements map[int]float64
	ndims    int
	dims     []int
}

// Initialize a new array
func ZerosSparse(dims ...int) *SparseArray {
	A := new(SparseArray)
	A.elements = make(map[int]float64)
	A.ndims = len(dims)
	A.dims = dims
	return A
}

// Make sure index is within array dimensions
func (A *SparseArray) checkIndex(index []int) error {
	if BoundsCheck {
		if len(index) != A.ndims {
			err := fmt.Errorf("Index number of dimensions (%v) does not match "+
				"array number of dimensions.", len(index), A.ndims)
			return err
		}
		for i, dim := range A.dims {
			if index[i] >= dim {
				err := fmt.Errorf(
					"Index %v of dimension %v is greater than dimension "+
					"size %v.", index[i], i, A.dims[i])
				return err
			}
		}
	}
	return nil
}

// Convert n-dimensional index to one-dimensional index
func (A *SparseArray) Index(index []int) (index1d int) {
	if err := A.checkIndex(index); err != nil {
		panic(err)
	}
	for i := 0; i < len(index); i++ {
		mul := 1
		for j := i + 1; j < len(index); j++ {
			mul = mul * A.dims[j]
		}
		index1d = index1d + index[i]*mul
	}
	return index1d
}

// Set index to val.
func (A *SparseArray) Set(val float64, index ...int) {
	if err := A.checkIndex(index); err != nil {
		panic(err)
	}
	index1d := A.Index(index)
	A.elements[index1d] = val
}

// Get array value at index
func (A *SparseArray) Get(index ...int) float64 {
	if err := A.checkIndex(index); err != nil {
		panic(err)
	}
	index1d := A.Index(index)
	val, ok := A.elements[index1d]
	if ok {
		return val
	} else {
		return 0.
	}
}

// Add val at array index
func (A *SparseArray) AddVal(val float64, index ...int) {
	if err := A.checkIndex(index); err != nil {
		panic(err)
	}
	index1d := A.Index(index)
	ArrayVal, ok := A.elements[index1d]
	if ok {
		ArrayVal += val
	} else {
		A.elements[index1d] = val
	}
}

// Subtract val at array index
func (A *SparseArray) SubtractVal(val float64, index ...int) {
	if err := A.checkIndex(index); err != nil {
		panic(err)
	}
	index1d := A.Index(index)
	ArrayVal, ok := A.elements[index1d]
	if ok {
		ArrayVal -= val
	} else {
		A.elements[index1d] = -1 * val
	}
}

// Multiply entire array by val
func (A *SparseArray) Scale(val float64) {
	for _, e := range A.elements {
		e *= val
	}
}

func (A *SparseArray) Sum() float64 {
	sum := 0.
	for _, e := range A.elements {
		sum += e
	}
	return sum
}

func (A *SparseArray) NonZero() []int {

}
